diff --git a/init_linux.go b/init_linux.go
new file mode 100644
index 0000000..ff6b758
--- /dev/null
+++ b/init_linux.go
@@ -0,0 +1,10 @@
+//go:build linux && !android
+
+package anet
+
+func init() {
+	// Force the custom netlink implementation (without Bind()) on Linux.
+	// This avoids "route ip+net: netlinkrib: permission denied" errors
+	// in restricted environments like Android's proot.
+	customAndroidApiLevel = android11ApiLevel
+}
diff --git a/interface.go b/interface.go
index 384f29c..1184d01 100644
--- a/interface.go
+++ b/interface.go
@@ -1,5 +1,4 @@
-//go:build !android
-// +build !android
+//go:build !android && !linux
 
 package anet
 
@@ -27,4 +26,14 @@ func InterfaceAddrsByInterface(ifi *net.Interface) ([]net.Addr, error) {
 	return ifi.Addrs()
 }
 
+// InterfaceByName returns the interface specified by name.
+func InterfaceByName(name string) (*net.Interface, error) {
+	return net.InterfaceByName(name)
+}
+
+// InterfaceByIndex returns the interface specified by index.
+func InterfaceByIndex(index int) (*net.Interface, error) {
+	return net.InterfaceByIndex(index)
+}
+
 func SetAndroidVersion(version uint) {}
diff --git a/interface_android.go b/interface_android.go
deleted file mode 100644
index 6b080c5..0000000
--- a/interface_android.go
+++ /dev/null
@@ -1,442 +0,0 @@
-package anet
-
-import (
-	"bytes"
-	"errors"
-	"net"
-	"os"
-	"sync"
-	"syscall"
-	"time"
-	"unsafe"
-)
-
-const (
-	android11ApiLevel = 30
-)
-
-var (
-	customAndroidApiLevel       = -1
-	errInvalidInterface         = errors.New("invalid network interface")
-	errInvalidInterfaceIndex    = errors.New("invalid network interface index")
-	errInvalidInterfaceName     = errors.New("invalid network interface name")
-	errNoSuchInterface          = errors.New("no such network interface")
-	errNoSuchMulticastInterface = errors.New("no such multicast network interface")
-)
-
-type ifReq [40]byte
-
-// Interfaces returns a list of the system's network interfaces.
-func Interfaces() ([]net.Interface, error) {
-	if androidApiLevel() < android11ApiLevel {
-		return net.Interfaces()
-	}
-
-	ift, err := interfaceTable(0)
-	if err != nil {
-		return nil, &net.OpError{Op: "route", Net: "ip+net", Source: nil, Addr: nil, Err: err}
-	}
-	if len(ift) != 0 {
-		zoneCache.update(ift, true)
-		zoneCacheX.update(ift, true)
-	}
-	return ift, nil
-}
-
-// InterfaceAddrs returns a list of the system's unicast interface
-// addresses.
-//
-// The returned list does not identify the associated interface; use
-// Interfaces and Interface.Addrs for more detail.
-func InterfaceAddrs() ([]net.Addr, error) {
-	if androidApiLevel() < android11ApiLevel {
-		return net.InterfaceAddrs()
-	}
-
-	ifat, err := interfaceAddrTable(nil)
-	if err != nil {
-		err = &net.OpError{Op: "route", Net: "ip+net", Source: nil, Addr: nil, Err: err}
-	}
-	return ifat, err
-}
-
-// InterfaceByIndex returns the interface specified by index.
-//
-// On Solaris, it returns one of the logical network interfaces
-// sharing the logical data link; for more precision use
-// InterfaceByName.
-func InterfaceByIndex(index int) (*net.Interface, error) {
-	if androidApiLevel() < android11ApiLevel {
-		return net.InterfaceByIndex(index)
-	}
-
-	if index <= 0 {
-		return nil, &net.OpError{Op: "route", Net: "ip+net", Source: nil, Addr: nil, Err: errInvalidInterfaceIndex}
-	}
-	ift, err := interfaceTable(index)
-	if err != nil {
-		return nil, &net.OpError{Op: "route", Net: "ip+net", Source: nil, Addr: nil, Err: err}
-	}
-	ifi, err := interfaceByIndex(ift, index)
-	if err != nil {
-		err = &net.OpError{Op: "route", Net: "ip+net", Source: nil, Addr: nil, Err: err}
-	}
-	return ifi, err
-}
-
-// InterfaceByName returns the interface specified by name.
-func InterfaceByName(name string) (*net.Interface, error) {
-	if name == "" {
-		return nil, &net.OpError{Op: "route", Net: "ip+net", Source: nil, Addr: nil, Err: errInvalidInterfaceName}
-	}
-	ift, err := interfaceTable(0)
-	if err != nil {
-		return nil, &net.OpError{Op: "route", Net: "ip+net", Source: nil, Addr: nil, Err: err}
-	}
-	if len(ift) != 0 {
-		zoneCache.update(ift, true)
-		zoneCacheX.update(ift, true)
-	}
-	for _, ifi := range ift {
-		if name == ifi.Name {
-			return &ifi, nil
-		}
-	}
-	return nil, &net.OpError{Op: "route", Net: "ip+net", Source: nil, Addr: nil, Err: errNoSuchInterface}
-}
-
-// InterfaceAddrsByInterface returns a list of the system's unicast
-// interface addresses by specific interface.
-func InterfaceAddrsByInterface(ifi *net.Interface) ([]net.Addr, error) {
-	if ifi == nil {
-		return nil, &net.OpError{Op: "route", Net: "ip+net", Source: nil, Addr: nil, Err: errInvalidInterface}
-	}
-
-	if androidApiLevel() < android11ApiLevel {
-		return ifi.Addrs()
-	}
-
-	ifat, err := interfaceAddrTable(ifi)
-	if err != nil {
-		err = &net.OpError{Op: "route", Net: "ip+net", Source: nil, Addr: nil, Err: err}
-	}
-	return ifat, err
-}
-
-// SetAndroidVersion set the Android environment in which the program runs.
-// The Android system version number can be obtained through
-// `android.os.Build.VERSION.RELEASE` of the Android framework.
-// If version is 0 the actual version will be detected automatically if possible.
-func SetAndroidVersion(version uint) {
-	switch {
-	case version == 0:
-		customAndroidApiLevel = -1
-	case version >= 11:
-		customAndroidApiLevel = android11ApiLevel
-	default:
-		customAndroidApiLevel = 0
-	}
-}
-
-func androidApiLevel() int {
-	if customAndroidApiLevel != -1 {
-		// user-provided api level should be used
-		return customAndroidApiLevel
-	}
-
-	// try to autodetect api level
-	return androidDeviceApiLevel()
-}
-
-// An ipv6ZoneCache represents a cache holding partial network
-// interface information. It is used for reducing the cost of IPv6
-// addressing scope zone resolution.
-//
-// Multiple names sharing the index are managed by first-come
-// first-served basis for consistency.
-type ipv6ZoneCache struct {
-	sync.RWMutex                // guard the following
-	lastFetched  time.Time      // last time routing information was fetched
-	toIndex      map[string]int // interface name to its index
-	toName       map[int]string // interface index to its name
-}
-
-//go:linkname zoneCache net.zoneCache
-var zoneCache ipv6ZoneCache
-
-//go:linkname zoneCacheX golang.org/x/net/internal/socket.zoneCache
-var zoneCacheX ipv6ZoneCache
-
-// update refreshes the network interface information if the cache was last
-// updated more than 1 minute ago, or if force is set. It reports whether the
-// cache was updated.
-func (zc *ipv6ZoneCache) update(ift []net.Interface, force bool) (updated bool) {
-	zc.Lock()
-	defer zc.Unlock()
-	now := time.Now()
-	if !force && zc.lastFetched.After(now.Add(-60*time.Second)) {
-		return false
-	}
-	zc.lastFetched = now
-	if len(ift) == 0 {
-		var err error
-		if ift, err = interfaceTable(0); err != nil {
-			return false
-		}
-	}
-	zc.toIndex = make(map[string]int, len(ift))
-	zc.toName = make(map[int]string, len(ift))
-	for _, ifi := range ift {
-		zc.toIndex[ifi.Name] = ifi.Index
-		if _, ok := zc.toName[ifi.Index]; !ok {
-			zc.toName[ifi.Index] = ifi.Name
-		}
-	}
-	return true
-}
-
-// If the ifindex is zero, interfaceTable returns mappings of all
-// network interfaces. Otherwise it returns a mapping of a specific
-// interface.
-func interfaceTable(ifindex int) ([]net.Interface, error) {
-	tab, err := NetlinkRIB(syscall.RTM_GETADDR, syscall.AF_UNSPEC)
-	if err != nil {
-		return nil, os.NewSyscallError("netlinkrib", err)
-	}
-	msgs, err := syscall.ParseNetlinkMessage(tab)
-	if err != nil {
-		return nil, os.NewSyscallError("parsenetlinkmessage", err)
-	}
-
-	var ift []net.Interface
-	im := make(map[uint32]struct{})
-loop:
-	for _, m := range msgs {
-		switch m.Header.Type {
-		case syscall.NLMSG_DONE:
-			break loop
-		case syscall.RTM_NEWADDR:
-			ifam := (*syscall.IfAddrmsg)(unsafe.Pointer(&m.Data[0]))
-			if _, ok := im[ifam.Index]; ok {
-				continue
-			} else {
-				im[ifam.Index] = struct{}{}
-			}
-
-			if ifindex == 0 || ifindex == int(ifam.Index) {
-				ifi := newLink(ifam)
-				if ifi != nil {
-					ift = append(ift, *ifi)
-				}
-				if ifindex == int(ifam.Index) {
-					break loop
-				}
-			}
-		}
-	}
-
-	return ift, nil
-}
-
-func newLink(ifam *syscall.IfAddrmsg) *net.Interface {
-	ift := &net.Interface{Index: int(ifam.Index)}
-
-	name, err := indexToName(ifam.Index)
-	if err != nil {
-		return nil
-	}
-	ift.Name = name
-
-	mtu, err := nameToMTU(name)
-	if err != nil {
-		return nil
-	}
-	ift.MTU = mtu
-
-	flags, err := nameToFlags(name)
-	if err != nil {
-		return nil
-	}
-	ift.Flags = flags
-	return ift
-}
-
-func linkFlags(rawFlags uint32) net.Flags {
-	var f net.Flags
-	if rawFlags&syscall.IFF_UP != 0 {
-		f |= net.FlagUp
-	}
-	if rawFlags&syscall.IFF_RUNNING != 0 {
-		f |= net.FlagRunning
-	}
-	if rawFlags&syscall.IFF_BROADCAST != 0 {
-		f |= net.FlagBroadcast
-	}
-	if rawFlags&syscall.IFF_LOOPBACK != 0 {
-		f |= net.FlagLoopback
-	}
-	if rawFlags&syscall.IFF_POINTOPOINT != 0 {
-		f |= net.FlagPointToPoint
-	}
-	if rawFlags&syscall.IFF_MULTICAST != 0 {
-		f |= net.FlagMulticast
-	}
-	return f
-}
-
-// If the ifi is nil, interfaceAddrTable returns addresses for all
-// network interfaces. Otherwise it returns addresses for a specific
-// interface.
-func interfaceAddrTable(ifi *net.Interface) ([]net.Addr, error) {
-	tab, err := NetlinkRIB(syscall.RTM_GETADDR, syscall.AF_UNSPEC)
-	if err != nil {
-		return nil, os.NewSyscallError("netlinkrib", err)
-	}
-	msgs, err := syscall.ParseNetlinkMessage(tab)
-	if err != nil {
-		return nil, os.NewSyscallError("parsenetlinkmessage", err)
-	}
-
-	var ift []net.Interface
-	if ifi == nil {
-		var err error
-		ift, err = interfaceTable(0)
-		if err != nil {
-			return nil, err
-		}
-	}
-	ifat, err := addrTable(ift, ifi, msgs)
-	if err != nil {
-		return nil, err
-	}
-	return ifat, nil
-}
-
-func addrTable(ift []net.Interface, ifi *net.Interface, msgs []syscall.NetlinkMessage) ([]net.Addr, error) {
-	var ifat []net.Addr
-loop:
-	for _, m := range msgs {
-		switch m.Header.Type {
-		case syscall.NLMSG_DONE:
-			break loop
-		case syscall.RTM_NEWADDR:
-			ifam := (*syscall.IfAddrmsg)(unsafe.Pointer(&m.Data[0]))
-			if len(ift) != 0 || ifi.Index == int(ifam.Index) {
-				attrs, err := syscall.ParseNetlinkRouteAttr(&m)
-				if err != nil {
-					return nil, os.NewSyscallError("parsenetlinkrouteattr", err)
-				}
-				ifa := newAddr(ifam, attrs)
-				if ifa != nil {
-					ifat = append(ifat, ifa)
-				}
-			}
-		}
-	}
-	return ifat, nil
-}
-
-func newAddr(ifam *syscall.IfAddrmsg, attrs []syscall.NetlinkRouteAttr) net.Addr {
-	var ipPointToPoint bool
-	// Seems like we need to make sure whether the IP interface
-	// stack consists of IP point-to-point numbered or unnumbered
-	// addressing.
-	for _, a := range attrs {
-		if a.Attr.Type == syscall.IFA_LOCAL {
-			ipPointToPoint = true
-			break
-		}
-	}
-	for _, a := range attrs {
-		if ipPointToPoint && a.Attr.Type == syscall.IFA_ADDRESS {
-			continue
-		}
-		switch ifam.Family {
-		case syscall.AF_INET:
-			return &net.IPNet{IP: net.IPv4(a.Value[0], a.Value[1], a.Value[2], a.Value[3]), Mask: net.CIDRMask(int(ifam.Prefixlen), 8*net.IPv4len)}
-		case syscall.AF_INET6:
-			ifa := &net.IPNet{IP: make(net.IP, net.IPv6len), Mask: net.CIDRMask(int(ifam.Prefixlen), 8*net.IPv6len)}
-			copy(ifa.IP, a.Value[:])
-			return ifa
-		}
-	}
-	return nil
-}
-
-func interfaceByIndex(ift []net.Interface, index int) (*net.Interface, error) {
-	for _, ifi := range ift {
-		if index == ifi.Index {
-			return &ifi, nil
-		}
-	}
-	return nil, errNoSuchInterface
-}
-
-func ioctl(fd int, req uint, arg unsafe.Pointer) error {
-	_, _, e1 := syscall.Syscall(syscall.SYS_IOCTL, uintptr(fd), uintptr(req), uintptr(arg))
-	if e1 != 0 {
-		return e1
-	}
-	return nil
-}
-
-func indexToName(index uint32) (string, error) {
-	fd, err := syscall.Socket(syscall.AF_INET, syscall.SOCK_DGRAM|syscall.SOCK_CLOEXEC, 0)
-	if err != nil {
-		return "", err
-	}
-	defer syscall.Close(fd)
-
-	var ifr ifReq
-	*(*uint32)(unsafe.Pointer(&ifr[syscall.IFNAMSIZ])) = index
-	err = ioctl(fd, syscall.SIOCGIFNAME, unsafe.Pointer(&ifr[0]))
-	if err != nil {
-		return "", err
-	}
-
-	return string(bytes.Trim(ifr[:syscall.IFNAMSIZ], "\x00")), nil
-}
-
-func nameToMTU(name string) (int, error) {
-	// Leave room for terminating NULL byte.
-	if len(name) >= syscall.IFNAMSIZ {
-		return -1, syscall.EINVAL
-	}
-
-	fd, err := syscall.Socket(syscall.AF_INET, syscall.SOCK_DGRAM|syscall.SOCK_CLOEXEC, 0)
-	if err != nil {
-		return -1, err
-	}
-	defer syscall.Close(fd)
-
-	var ifr ifReq
-	copy(ifr[:], name)
-	err = ioctl(fd, syscall.SIOCGIFMTU, unsafe.Pointer(&ifr[0]))
-	if err != nil {
-		return -1, err
-	}
-
-	return int(*(*int32)(unsafe.Pointer(&ifr[syscall.IFNAMSIZ]))), nil
-}
-
-func nameToFlags(name string) (net.Flags, error) {
-	// Leave room for terminating NULL byte.
-	if len(name) >= syscall.IFNAMSIZ {
-		return 0, syscall.EINVAL
-	}
-
-	fd, err := syscall.Socket(syscall.AF_INET, syscall.SOCK_DGRAM|syscall.SOCK_CLOEXEC, 0)
-	if err != nil {
-		return 0, err
-	}
-	defer syscall.Close(fd)
-
-	var ifr ifReq
-	copy(ifr[:], name)
-	err = ioctl(fd, syscall.SIOCGIFFLAGS, unsafe.Pointer(&ifr[0]))
-	if err != nil {
-		return 0, err
-	}
-
-	return linkFlags(*(*uint32)(unsafe.Pointer(&ifr[syscall.IFNAMSIZ]))), nil
-}
diff --git a/interface_fixup.go b/interface_fixup.go
new file mode 100644
index 0000000..c81f681
--- /dev/null
+++ b/interface_fixup.go
@@ -0,0 +1,444 @@
+//go:build android || linux
+
+package anet
+
+import (
+	"bytes"
+	"errors"
+	"net"
+	"os"
+	"sync"
+	"syscall"
+	"time"
+	"unsafe"
+)
+
+const (
+	android11ApiLevel = 30
+)
+
+var (
+	customAndroidApiLevel       = -1
+	errInvalidInterface         = errors.New("invalid network interface")
+	errInvalidInterfaceIndex    = errors.New("invalid network interface index")
+	errInvalidInterfaceName     = errors.New("invalid network interface name")
+	errNoSuchInterface          = errors.New("no such network interface")
+	errNoSuchMulticastInterface = errors.New("no such multicast network interface")
+)
+
+type ifReq [40]byte
+
+// Interfaces returns a list of the system's network interfaces.
+func Interfaces() ([]net.Interface, error) {
+	if androidApiLevel() < android11ApiLevel {
+		return net.Interfaces()
+	}
+
+	ift, err := interfaceTable(0)
+	if err != nil {
+		return nil, &net.OpError{Op: "route", Net: "ip+net", Source: nil, Addr: nil, Err: err}
+	}
+	if len(ift) != 0 {
+		zoneCache.update(ift, true)
+		zoneCacheX.update(ift, true)
+	}
+	return ift, nil
+}
+
+// InterfaceAddrs returns a list of the system's unicast interface
+// addresses.
+//
+// The returned list does not identify the associated interface; use
+// Interfaces and Interface.Addrs for more detail.
+func InterfaceAddrs() ([]net.Addr, error) {
+	if androidApiLevel() < android11ApiLevel {
+		return net.InterfaceAddrs()
+	}
+
+	ifat, err := interfaceAddrTable(nil)
+	if err != nil {
+		err = &net.OpError{Op: "route", Net: "ip+net", Source: nil, Addr: nil, Err: err}
+	}
+	return ifat, err
+}
+
+// InterfaceByIndex returns the interface specified by index.
+//
+// On Solaris, it returns one of the logical network interfaces
+// sharing the logical data link; for more precision use
+// InterfaceByName.
+func InterfaceByIndex(index int) (*net.Interface, error) {
+	if androidApiLevel() < android11ApiLevel {
+		return net.InterfaceByIndex(index)
+	}
+
+	if index <= 0 {
+		return nil, &net.OpError{Op: "route", Net: "ip+net", Source: nil, Addr: nil, Err: errInvalidInterfaceIndex}
+	}
+	ift, err := interfaceTable(index)
+	if err != nil {
+		return nil, &net.OpError{Op: "route", Net: "ip+net", Source: nil, Addr: nil, Err: err}
+	}
+	ifi, err := interfaceByIndex(ift, index)
+	if err != nil {
+		err = &net.OpError{Op: "route", Net: "ip+net", Source: nil, Addr: nil, Err: err}
+	}
+	return ifi, err
+}
+
+// InterfaceByName returns the interface specified by name.
+func InterfaceByName(name string) (*net.Interface, error) {
+	if name == "" {
+		return nil, &net.OpError{Op: "route", Net: "ip+net", Source: nil, Addr: nil, Err: errInvalidInterfaceName}
+	}
+	ift, err := interfaceTable(0)
+	if err != nil {
+		return nil, &net.OpError{Op: "route", Net: "ip+net", Source: nil, Addr: nil, Err: err}
+	}
+	if len(ift) != 0 {
+		zoneCache.update(ift, true)
+		zoneCacheX.update(ift, true)
+	}
+	for _, ifi := range ift {
+		if name == ifi.Name {
+			return &ifi, nil
+		}
+	}
+	return nil, &net.OpError{Op: "route", Net: "ip+net", Source: nil, Addr: nil, Err: errNoSuchInterface}
+}
+
+// InterfaceAddrsByInterface returns a list of the system's unicast
+// interface addresses by specific interface.
+func InterfaceAddrsByInterface(ifi *net.Interface) ([]net.Addr, error) {
+	if ifi == nil {
+		return nil, &net.OpError{Op: "route", Net: "ip+net", Source: nil, Addr: nil, Err: errInvalidInterface}
+	}
+
+	if androidApiLevel() < android11ApiLevel {
+		return ifi.Addrs()
+	}
+
+	ifat, err := interfaceAddrTable(ifi)
+	if err != nil {
+		err = &net.OpError{Op: "route", Net: "ip+net", Source: nil, Addr: nil, Err: err}
+	}
+	return ifat, err
+}
+
+// SetAndroidVersion set the Android environment in which the program runs.
+// The Android system version number can be obtained through
+// `android.os.Build.VERSION.RELEASE` of the Android framework.
+// If version is 0 the actual version will be detected automatically if possible.
+func SetAndroidVersion(version uint) {
+	switch {
+	case version == 0:
+		customAndroidApiLevel = -1
+	case version >= 11:
+		customAndroidApiLevel = android11ApiLevel
+	default:
+		customAndroidApiLevel = 0
+	}
+}
+
+func androidApiLevel() int {
+	if customAndroidApiLevel != -1 {
+		// user-provided api level should be used
+		return customAndroidApiLevel
+	}
+
+	// try to autodetect api level
+	return androidDeviceApiLevel()
+}
+
+// An ipv6ZoneCache represents a cache holding partial network
+// interface information. It is used for reducing the cost of IPv6
+// addressing scope zone resolution.
+//
+// Multiple names sharing the index are managed by first-come
+// first-served basis for consistency.
+type ipv6ZoneCache struct {
+	sync.RWMutex                // guard the following
+	lastFetched  time.Time      // last time routing information was fetched
+	toIndex      map[string]int // interface name to its index
+	toName       map[int]string // interface index to its name
+}
+
+//go:linkname zoneCache net.zoneCache
+var zoneCache ipv6ZoneCache
+
+//go:linkname zoneCacheX golang.org/x/net/internal/socket.zoneCache
+var zoneCacheX ipv6ZoneCache
+
+// update refreshes the network interface information if the cache was last
+// updated more than 1 minute ago, or if force is set. It reports whether the
+// cache was updated.
+func (zc *ipv6ZoneCache) update(ift []net.Interface, force bool) (updated bool) {
+	zc.Lock()
+	defer zc.Unlock()
+	now := time.Now()
+	if !force && zc.lastFetched.After(now.Add(-60*time.Second)) {
+		return false
+	}
+	zc.lastFetched = now
+	if len(ift) == 0 {
+		var err error
+		if ift, err = interfaceTable(0); err != nil {
+			return false
+		}
+	}
+	zc.toIndex = make(map[string]int, len(ift))
+	zc.toName = make(map[int]string, len(ift))
+	for _, ifi := range ift {
+		zc.toIndex[ifi.Name] = ifi.Index
+		if _, ok := zc.toName[ifi.Index]; !ok {
+			zc.toName[ifi.Index] = ifi.Name
+		}
+	}
+	return true
+}
+
+// If the ifindex is zero, interfaceTable returns mappings of all
+// network interfaces. Otherwise it returns a mapping of a specific
+// interface.
+func interfaceTable(ifindex int) ([]net.Interface, error) {
+	tab, err := NetlinkRIB(syscall.RTM_GETADDR, syscall.AF_UNSPEC)
+	if err != nil {
+		return nil, os.NewSyscallError("netlinkrib", err)
+	}
+	msgs, err := syscall.ParseNetlinkMessage(tab)
+	if err != nil {
+		return nil, os.NewSyscallError("parsenetlinkmessage", err)
+	}
+
+	var ift []net.Interface
+	im := make(map[uint32]struct{})
+loop:
+	for _, m := range msgs {
+		switch m.Header.Type {
+		case syscall.NLMSG_DONE:
+			break loop
+		case syscall.RTM_NEWADDR:
+			ifam := (*syscall.IfAddrmsg)(unsafe.Pointer(&m.Data[0]))
+			if _, ok := im[ifam.Index]; ok {
+				continue
+			} else {
+				im[ifam.Index] = struct{}{}
+			}
+
+			if ifindex == 0 || ifindex == int(ifam.Index) {
+				ifi := newLink(ifam)
+				if ifi != nil {
+					ift = append(ift, *ifi)
+				}
+				if ifindex == int(ifam.Index) {
+					break loop
+				}
+			}
+		}
+	}
+
+	return ift, nil
+}
+
+func newLink(ifam *syscall.IfAddrmsg) *net.Interface {
+	ift := &net.Interface{Index: int(ifam.Index)}
+
+	name, err := indexToName(ifam.Index)
+	if err != nil {
+		return nil
+	}
+	ift.Name = name
+
+	mtu, err := nameToMTU(name)
+	if err != nil {
+		return nil
+	}
+	ift.MTU = mtu
+
+	flags, err := nameToFlags(name)
+	if err != nil {
+		return nil
+	}
+	ift.Flags = flags
+	return ift
+}
+
+func linkFlags(rawFlags uint32) net.Flags {
+	var f net.Flags
+	if rawFlags&syscall.IFF_UP != 0 {
+		f |= net.FlagUp
+	}
+	if rawFlags&syscall.IFF_RUNNING != 0 {
+		f |= net.FlagRunning
+	}
+	if rawFlags&syscall.IFF_BROADCAST != 0 {
+		f |= net.FlagBroadcast
+	}
+	if rawFlags&syscall.IFF_LOOPBACK != 0 {
+		f |= net.FlagLoopback
+	}
+	if rawFlags&syscall.IFF_POINTOPOINT != 0 {
+		f |= net.FlagPointToPoint
+	}
+	if rawFlags&syscall.IFF_MULTICAST != 0 {
+		f |= net.FlagMulticast
+	}
+	return f
+}
+
+// If the ifi is nil, interfaceAddrTable returns addresses for all
+// network interfaces. Otherwise it returns addresses for a specific
+// interface.
+func interfaceAddrTable(ifi *net.Interface) ([]net.Addr, error) {
+	tab, err := NetlinkRIB(syscall.RTM_GETADDR, syscall.AF_UNSPEC)
+	if err != nil {
+		return nil, os.NewSyscallError("netlinkrib", err)
+	}
+	msgs, err := syscall.ParseNetlinkMessage(tab)
+	if err != nil {
+		return nil, os.NewSyscallError("parsenetlinkmessage", err)
+	}
+
+	var ift []net.Interface
+	if ifi == nil {
+		var err error
+		ift, err = interfaceTable(0)
+		if err != nil {
+			return nil, err
+		}
+	}
+	ifat, err := addrTable(ift, ifi, msgs)
+	if err != nil {
+		return nil, err
+	}
+	return ifat, nil
+}
+
+func addrTable(ift []net.Interface, ifi *net.Interface, msgs []syscall.NetlinkMessage) ([]net.Addr, error) {
+	var ifat []net.Addr
+loop:
+	for _, m := range msgs {
+		switch m.Header.Type {
+		case syscall.NLMSG_DONE:
+			break loop
+		case syscall.RTM_NEWADDR:
+			ifam := (*syscall.IfAddrmsg)(unsafe.Pointer(&m.Data[0]))
+			if len(ift) != 0 || ifi.Index == int(ifam.Index) {
+				attrs, err := syscall.ParseNetlinkRouteAttr(&m)
+				if err != nil {
+					return nil, os.NewSyscallError("parsenetlinkrouteattr", err)
+				}
+				ifa := newAddr(ifam, attrs)
+				if ifa != nil {
+					ifat = append(ifat, ifa)
+				}
+			}
+		}
+	}
+	return ifat, nil
+}
+
+func newAddr(ifam *syscall.IfAddrmsg, attrs []syscall.NetlinkRouteAttr) net.Addr {
+	var ipPointToPoint bool
+	// Seems like we need to make sure whether the IP interface
+	// stack consists of IP point-to-point numbered or unnumbered
+	// addressing.
+	for _, a := range attrs {
+		if a.Attr.Type == syscall.IFA_LOCAL {
+			ipPointToPoint = true
+			break
+		}
+	}
+	for _, a := range attrs {
+		if ipPointToPoint && a.Attr.Type == syscall.IFA_ADDRESS {
+			continue
+		}
+		switch ifam.Family {
+		case syscall.AF_INET:
+			return &net.IPNet{IP: net.IPv4(a.Value[0], a.Value[1], a.Value[2], a.Value[3]), Mask: net.CIDRMask(int(ifam.Prefixlen), 8*net.IPv4len)}
+		case syscall.AF_INET6:
+			ifa := &net.IPNet{IP: make(net.IP, net.IPv6len), Mask: net.CIDRMask(int(ifam.Prefixlen), 8*net.IPv6len)}
+			copy(ifa.IP, a.Value[:])
+			return ifa
+		}
+	}
+	return nil
+}
+
+func interfaceByIndex(ift []net.Interface, index int) (*net.Interface, error) {
+	for _, ifi := range ift {
+		if index == ifi.Index {
+			return &ifi, nil
+		}
+	}
+	return nil, errNoSuchInterface
+}
+
+func ioctl(fd int, req uint, arg unsafe.Pointer) error {
+	_, _, e1 := syscall.Syscall(syscall.SYS_IOCTL, uintptr(fd), uintptr(req), uintptr(arg))
+	if e1 != 0 {
+		return e1
+	}
+	return nil
+}
+
+func indexToName(index uint32) (string, error) {
+	fd, err := syscall.Socket(syscall.AF_INET, syscall.SOCK_DGRAM|syscall.SOCK_CLOEXEC, 0)
+	if err != nil {
+		return "", err
+	}
+	defer syscall.Close(fd)
+
+	var ifr ifReq
+	*(*uint32)(unsafe.Pointer(&ifr[syscall.IFNAMSIZ])) = index
+	err = ioctl(fd, syscall.SIOCGIFNAME, unsafe.Pointer(&ifr[0]))
+	if err != nil {
+		return "", err
+	}
+
+	return string(bytes.Trim(ifr[:syscall.IFNAMSIZ], "\x00")), nil
+}
+
+func nameToMTU(name string) (int, error) {
+	// Leave room for terminating NULL byte.
+	if len(name) >= syscall.IFNAMSIZ {
+		return -1, syscall.EINVAL
+	}
+
+	fd, err := syscall.Socket(syscall.AF_INET, syscall.SOCK_DGRAM|syscall.SOCK_CLOEXEC, 0)
+	if err != nil {
+		return -1, err
+	}
+	defer syscall.Close(fd)
+
+	var ifr ifReq
+	copy(ifr[:], name)
+	err = ioctl(fd, syscall.SIOCGIFMTU, unsafe.Pointer(&ifr[0]))
+	if err != nil {
+		return -1, err
+	}
+
+	return int(*(*int32)(unsafe.Pointer(&ifr[syscall.IFNAMSIZ]))), nil
+}
+
+func nameToFlags(name string) (net.Flags, error) {
+	// Leave room for terminating NULL byte.
+	if len(name) >= syscall.IFNAMSIZ {
+		return 0, syscall.EINVAL
+	}
+
+	fd, err := syscall.Socket(syscall.AF_INET, syscall.SOCK_DGRAM|syscall.SOCK_CLOEXEC, 0)
+	if err != nil {
+		return 0, err
+	}
+	defer syscall.Close(fd)
+
+	var ifr ifReq
+	copy(ifr[:], name)
+	err = ioctl(fd, syscall.SIOCGIFFLAGS, unsafe.Pointer(&ifr[0]))
+	if err != nil {
+		return 0, err
+	}
+
+	return linkFlags(*(*uint32)(unsafe.Pointer(&ifr[syscall.IFNAMSIZ]))), nil
+}
diff --git a/netlink_android.go b/netlink_android.go
deleted file mode 100644
index fc0d84d..0000000
--- a/netlink_android.go
+++ /dev/null
@@ -1,179 +0,0 @@
-// Copyright 2011 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-// Netlink sockets and messages
-
-package anet
-
-import (
-	"syscall"
-	"unsafe"
-)
-
-// Round the length of a netlink message up to align it properly.
-func nlmAlignOf(msglen int) int {
-	return (msglen + syscall.NLMSG_ALIGNTO - 1) & ^(syscall.NLMSG_ALIGNTO - 1)
-}
-
-// Round the length of a netlink route attribute up to align it
-// properly.
-func rtaAlignOf(attrlen int) int {
-	return (attrlen + syscall.RTA_ALIGNTO - 1) & ^(syscall.RTA_ALIGNTO - 1)
-}
-
-// NetlinkRouteRequest represents a request message to receive routing
-// and link states from the kernel.
-type NetlinkRouteRequest struct {
-	Header syscall.NlMsghdr
-	Data   syscall.RtGenmsg
-}
-
-func (rr *NetlinkRouteRequest) toWireFormat() []byte {
-	b := make([]byte, rr.Header.Len)
-	*(*uint32)(unsafe.Pointer(&b[0:4][0])) = rr.Header.Len
-	*(*uint16)(unsafe.Pointer(&b[4:6][0])) = rr.Header.Type
-	*(*uint16)(unsafe.Pointer(&b[6:8][0])) = rr.Header.Flags
-	*(*uint32)(unsafe.Pointer(&b[8:12][0])) = rr.Header.Seq
-	*(*uint32)(unsafe.Pointer(&b[12:16][0])) = rr.Header.Pid
-	b[16] = byte(rr.Data.Family)
-	return b
-}
-
-func newNetlinkRouteRequest(proto, seq, family int) []byte {
-	rr := &NetlinkRouteRequest{}
-	rr.Header.Len = uint32(syscall.NLMSG_HDRLEN + syscall.SizeofRtGenmsg)
-	rr.Header.Type = uint16(proto)
-	rr.Header.Flags = syscall.NLM_F_DUMP | syscall.NLM_F_REQUEST
-	rr.Header.Seq = uint32(seq)
-	rr.Data.Family = uint8(family)
-	return rr.toWireFormat()
-}
-
-// NetlinkRIB returns routing information base, as known as RIB, which
-// consists of network facility information, states and parameters.
-func NetlinkRIB(proto, family int) ([]byte, error) {
-	s, err := syscall.Socket(syscall.AF_NETLINK, syscall.SOCK_RAW|syscall.SOCK_CLOEXEC, syscall.NETLINK_ROUTE)
-	if err != nil {
-		return nil, err
-	}
-	defer syscall.Close(s)
-	sa := &syscall.SockaddrNetlink{Family: syscall.AF_NETLINK}
-
-	wb := newNetlinkRouteRequest(proto, 1, family)
-	if err := syscall.Sendto(s, wb, 0, sa); err != nil {
-		return nil, err
-	}
-	lsa, err := syscall.Getsockname(s)
-	if err != nil {
-		return nil, err
-	}
-	lsanl, ok := lsa.(*syscall.SockaddrNetlink)
-	if !ok {
-		return nil, syscall.EINVAL
-	}
-	var tab []byte
-	rbNew := make([]byte, syscall.Getpagesize())
-done:
-	for {
-		rb := rbNew
-		nr, _, err := syscall.Recvfrom(s, rb, 0)
-		if err != nil {
-			return nil, err
-		}
-		if nr < syscall.NLMSG_HDRLEN {
-			return nil, syscall.EINVAL
-		}
-		rb = rb[:nr]
-		tab = append(tab, rb...)
-		msgs, err := ParseNetlinkMessage(rb)
-		if err != nil {
-			return nil, err
-		}
-		for _, m := range msgs {
-			if m.Header.Seq != 1 || m.Header.Pid != lsanl.Pid {
-				return nil, syscall.EINVAL
-			}
-			if m.Header.Type == syscall.NLMSG_DONE {
-				break done
-			}
-			if m.Header.Type == syscall.NLMSG_ERROR {
-				return nil, syscall.EINVAL
-			}
-		}
-	}
-	return tab, nil
-}
-
-// NetlinkMessage represents a netlink message.
-type NetlinkMessage struct {
-	Header syscall.NlMsghdr
-	Data   []byte
-}
-
-// ParseNetlinkMessage parses b as an array of netlink messages and
-// returns the slice containing the NetlinkMessage structures.
-func ParseNetlinkMessage(b []byte) ([]NetlinkMessage, error) {
-	var msgs []NetlinkMessage
-	for len(b) >= syscall.NLMSG_HDRLEN {
-		h, dbuf, dlen, err := netlinkMessageHeaderAndData(b)
-		if err != nil {
-			return nil, err
-		}
-		m := NetlinkMessage{Header: *h, Data: dbuf[:int(h.Len)-syscall.NLMSG_HDRLEN]}
-		msgs = append(msgs, m)
-		b = b[dlen:]
-	}
-	return msgs, nil
-}
-
-func netlinkMessageHeaderAndData(b []byte) (*syscall.NlMsghdr, []byte, int, error) {
-	h := (*syscall.NlMsghdr)(unsafe.Pointer(&b[0]))
-	l := nlmAlignOf(int(h.Len))
-	if int(h.Len) < syscall.NLMSG_HDRLEN || l > len(b) {
-		return nil, nil, 0, syscall.EINVAL
-	}
-	return h, b[syscall.NLMSG_HDRLEN:], l, nil
-}
-
-// NetlinkRouteAttr represents a netlink route attribute.
-type NetlinkRouteAttr struct {
-	Attr  syscall.RtAttr
-	Value []byte
-}
-
-// ParseNetlinkRouteAttr parses m's payload as an array of netlink
-// route attributes and returns the slice containing the
-// NetlinkRouteAttr structures.
-func ParseNetlinkRouteAttr(m *NetlinkMessage) ([]NetlinkRouteAttr, error) {
-	var b []byte
-	switch m.Header.Type {
-	case syscall.RTM_NEWLINK, syscall.RTM_DELLINK:
-		b = m.Data[syscall.SizeofIfInfomsg:]
-	case syscall.RTM_NEWADDR, syscall.RTM_DELADDR:
-		b = m.Data[syscall.SizeofIfAddrmsg:]
-	case syscall.RTM_NEWROUTE, syscall.RTM_DELROUTE:
-		b = m.Data[syscall.SizeofRtMsg:]
-	default:
-		return nil, syscall.EINVAL
-	}
-	var attrs []NetlinkRouteAttr
-	for len(b) >= syscall.SizeofRtAttr {
-		a, vbuf, alen, err := netlinkRouteAttrAndValue(b)
-		if err != nil {
-			return nil, err
-		}
-		ra := NetlinkRouteAttr{Attr: *a, Value: vbuf[:int(a.Len)-syscall.SizeofRtAttr]}
-		attrs = append(attrs, ra)
-		b = b[alen:]
-	}
-	return attrs, nil
-}
-
-func netlinkRouteAttrAndValue(b []byte) (*syscall.RtAttr, []byte, int, error) {
-	a := (*syscall.RtAttr)(unsafe.Pointer(&b[0]))
-	if int(a.Len) < syscall.SizeofRtAttr || int(a.Len) > len(b) {
-		return nil, nil, 0, syscall.EINVAL
-	}
-	return a, b[syscall.SizeofRtAttr:], rtaAlignOf(int(a.Len)), nil
-}
diff --git a/netlink_fixup.go b/netlink_fixup.go
new file mode 100644
index 0000000..5ca3a9f
--- /dev/null
+++ b/netlink_fixup.go
@@ -0,0 +1,181 @@
+// Copyright 2011 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+//go:build android || linux
+
+// Netlink sockets and messages
+
+package anet
+
+import (
+	"syscall"
+	"unsafe"
+)
+
+// Round the length of a netlink message up to align it properly.
+func nlmAlignOf(msglen int) int {
+	return (msglen + syscall.NLMSG_ALIGNTO - 1) & ^(syscall.NLMSG_ALIGNTO - 1)
+}
+
+// Round the length of a netlink route attribute up to align it
+// properly.
+func rtaAlignOf(attrlen int) int {
+	return (attrlen + syscall.RTA_ALIGNTO - 1) & ^(syscall.RTA_ALIGNTO - 1)
+}
+
+// NetlinkRouteRequest represents a request message to receive routing
+// and link states from the kernel.
+type NetlinkRouteRequest struct {
+	Header syscall.NlMsghdr
+	Data   syscall.RtGenmsg
+}
+
+func (rr *NetlinkRouteRequest) toWireFormat() []byte {
+	b := make([]byte, rr.Header.Len)
+	*(*uint32)(unsafe.Pointer(&b[0:4][0])) = rr.Header.Len
+	*(*uint16)(unsafe.Pointer(&b[4:6][0])) = rr.Header.Type
+	*(*uint16)(unsafe.Pointer(&b[6:8][0])) = rr.Header.Flags
+	*(*uint32)(unsafe.Pointer(&b[8:12][0])) = rr.Header.Seq
+	*(*uint32)(unsafe.Pointer(&b[12:16][0])) = rr.Header.Pid
+	b[16] = byte(rr.Data.Family)
+	return b
+}
+
+func newNetlinkRouteRequest(proto, seq, family int) []byte {
+	rr := &NetlinkRouteRequest{}
+	rr.Header.Len = uint32(syscall.NLMSG_HDRLEN + syscall.SizeofRtGenmsg)
+	rr.Header.Type = uint16(proto)
+	rr.Header.Flags = syscall.NLM_F_DUMP | syscall.NLM_F_REQUEST
+	rr.Header.Seq = uint32(seq)
+	rr.Data.Family = uint8(family)
+	return rr.toWireFormat()
+}
+
+// NetlinkRIB returns routing information base, as known as RIB, which
+// consists of network facility information, states and parameters.
+func NetlinkRIB(proto, family int) ([]byte, error) {
+	s, err := syscall.Socket(syscall.AF_NETLINK, syscall.SOCK_RAW|syscall.SOCK_CLOEXEC, syscall.NETLINK_ROUTE)
+	if err != nil {
+		return nil, err
+	}
+	defer syscall.Close(s)
+	sa := &syscall.SockaddrNetlink{Family: syscall.AF_NETLINK}
+
+	wb := newNetlinkRouteRequest(proto, 1, family)
+	if err := syscall.Sendto(s, wb, 0, sa); err != nil {
+		return nil, err
+	}
+	lsa, err := syscall.Getsockname(s)
+	if err != nil {
+		return nil, err
+	}
+	lsanl, ok := lsa.(*syscall.SockaddrNetlink)
+	if !ok {
+		return nil, syscall.EINVAL
+	}
+	var tab []byte
+	rbNew := make([]byte, syscall.Getpagesize())
+done:
+	for {
+		rb := rbNew
+		nr, _, err := syscall.Recvfrom(s, rb, 0)
+		if err != nil {
+			return nil, err
+		}
+		if nr < syscall.NLMSG_HDRLEN {
+			return nil, syscall.EINVAL
+		}
+		rb = rb[:nr]
+		tab = append(tab, rb...)
+		msgs, err := ParseNetlinkMessage(rb)
+		if err != nil {
+			return nil, err
+		}
+		for _, m := range msgs {
+			if m.Header.Seq != 1 || m.Header.Pid != lsanl.Pid {
+				return nil, syscall.EINVAL
+			}
+			if m.Header.Type == syscall.NLMSG_DONE {
+				break done
+			}
+			if m.Header.Type == syscall.NLMSG_ERROR {
+				return nil, syscall.EINVAL
+			}
+		}
+	}
+	return tab, nil
+}
+
+// NetlinkMessage represents a netlink message.
+type NetlinkMessage struct {
+	Header syscall.NlMsghdr
+	Data   []byte
+}
+
+// ParseNetlinkMessage parses b as an array of netlink messages and
+// returns the slice containing the NetlinkMessage structures.
+func ParseNetlinkMessage(b []byte) ([]NetlinkMessage, error) {
+	var msgs []NetlinkMessage
+	for len(b) >= syscall.NLMSG_HDRLEN {
+		h, dbuf, dlen, err := netlinkMessageHeaderAndData(b)
+		if err != nil {
+			return nil, err
+		}
+		m := NetlinkMessage{Header: *h, Data: dbuf[:int(h.Len)-syscall.NLMSG_HDRLEN]}
+		msgs = append(msgs, m)
+		b = b[dlen:]
+	}
+	return msgs, nil
+}
+
+func netlinkMessageHeaderAndData(b []byte) (*syscall.NlMsghdr, []byte, int, error) {
+	h := (*syscall.NlMsghdr)(unsafe.Pointer(&b[0]))
+	l := nlmAlignOf(int(h.Len))
+	if int(h.Len) < syscall.NLMSG_HDRLEN || l > len(b) {
+		return nil, nil, 0, syscall.EINVAL
+	}
+	return h, b[syscall.NLMSG_HDRLEN:], l, nil
+}
+
+// NetlinkRouteAttr represents a netlink route attribute.
+type NetlinkRouteAttr struct {
+	Attr  syscall.RtAttr
+	Value []byte
+}
+
+// ParseNetlinkRouteAttr parses m's payload as an array of netlink
+// route attributes and returns the slice containing the
+// NetlinkRouteAttr structures.
+func ParseNetlinkRouteAttr(m *NetlinkMessage) ([]NetlinkRouteAttr, error) {
+	var b []byte
+	switch m.Header.Type {
+	case syscall.RTM_NEWLINK, syscall.RTM_DELLINK:
+		b = m.Data[syscall.SizeofIfInfomsg:]
+	case syscall.RTM_NEWADDR, syscall.RTM_DELADDR:
+		b = m.Data[syscall.SizeofIfAddrmsg:]
+	case syscall.RTM_NEWROUTE, syscall.RTM_DELROUTE:
+		b = m.Data[syscall.SizeofRtMsg:]
+	default:
+		return nil, syscall.EINVAL
+	}
+	var attrs []NetlinkRouteAttr
+	for len(b) >= syscall.SizeofRtAttr {
+		a, vbuf, alen, err := netlinkRouteAttrAndValue(b)
+		if err != nil {
+			return nil, err
+		}
+		ra := NetlinkRouteAttr{Attr: *a, Value: vbuf[:int(a.Len)-syscall.SizeofRtAttr]}
+		attrs = append(attrs, ra)
+		b = b[alen:]
+	}
+	return attrs, nil
+}
+
+func netlinkRouteAttrAndValue(b []byte) (*syscall.RtAttr, []byte, int, error) {
+	a := (*syscall.RtAttr)(unsafe.Pointer(&b[0]))
+	if int(a.Len) < syscall.SizeofRtAttr || int(a.Len) > len(b) {
+		return nil, nil, 0, syscall.EINVAL
+	}
+	return a, b[syscall.SizeofRtAttr:], rtaAlignOf(int(a.Len)), nil
+}
